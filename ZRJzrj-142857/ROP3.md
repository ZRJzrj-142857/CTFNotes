ret2csu

我们可以利用 x64 下的 __libc_csu_init 中的 gadgets。这个函数是用来对 libc 进行初始化操作的，而一般的程序都会调用 libc 函数，所以这个函数一定会存在。

基本利用思路如下

利用栈溢出执行 libc_csu_gadgets 获取 write 函数地址，并使得程序重新执行 main 函数  
根据 libcsearcher 获取对应 libc 版本以及 execve 函数地址    
再次利用栈溢出执行 libc_csu_gadgets 向 bss 段写入 execve 地址以及 '/bin/sh’ 地址，并使得程序重新执行main 函数。     
再次利用栈溢出执行 libc_csu_gadgets 执行 execve('/bin/sh') 获取 shell。

那么当允许我们输入的字节数较少的时候，我们该怎么有什么办法呢？下面给出了几个方法

改进1 - 提前控制 RBX 与 RBP:                   
可以看到在我们之前的利用中，我们利用这两个寄存器的值的主要是为了满足 cmp 的条件，并进行跳转。如果我们可以提前控制这两个数值，那么我们就可以减少 16 字节，即我们所需的字节数只需要112。

改进2-多次利用:         
其实，改进 1 也算是一种多次利用。我们可以看到我们的 gadgets 是分为两部分的，那么我们其实可以进行两次调用来达到的目的，以便于减少一次 gadgets 所需要的字节数。但这里的多次利用需要更加严格的条件

漏洞可以被多次触发        
在两次触发之间，程序尚未修改 r12-r15 寄存器，这是因为要两次调用。     

当然，有时候我们也会遇到一次性可以读入大量的字节，但是不允许漏洞再次利用的情况，这时候就需要我们一次性将所有的字节布置好，之后慢慢利用。

ret2reg

原理

查看溢出函返回时哪个寄存值指向溢出缓冲区空间

然后反编译二进制，查找 call reg 或者jmp reg指令，将 EIP 设置为该指令地址

reg所指向的空间上注入 Shellcode (需要确保该空间是可以执行的，但通常都是栈上的)

blind ROP

BROP是没有对应应用程序的源代码或者二进制文件下，对程序进行攻击，劫持程序的执行流

判断栈溢出长度

暴力枚举

Stack Reading

获取栈上的数据来泄露canaries，以及ebp和返回地址。

Blind ROP

找到足够多的 gadgets 来控制输出函数的参数，并且对其进行调用，比如说常见的 write 函数以及puts函数。

Build the exploit

利用输出函数来 dump 出程序以便于来找到更多的 gadgets，从而可以写出最后的 exploit。

